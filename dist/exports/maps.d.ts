import { Possible } from "./types/utils";
export declare type MapStream<K, V> = Iterable<[K, V]>;
export declare function mapStream<K, T>(map: Map<K, T>): IterableIterator<[K, T]>;
export declare type Reconciler<K, T, V> = (colliding: Possible<V>, incoming: T, key: K) => V;
export declare function mapCollectInto<K, T>(iterable: Iterable<[K, T]>, seed: Map<K, T>): Map<K, T>;
export declare function mapCollectInto<K, T, V>(iterable: Iterable<[K, T]>, seed: Map<K, V>, reconcileFn: Reconciler<K, T, V>): Map<K, V>;
export declare function mapCollect<K, T>(iterable: Iterable<[K, T]>): Map<K, T>;
export declare function mapCollect<K, T, V>(iterable: Iterable<[K, T]>, reconcileFn: Reconciler<K, T, V>): Map<K, V>;
export declare function biMapCollect<K, T>(iterable: Iterable<[K, T]>): Map<K, T>;
export declare function biMapCollect<K, T, V>(iterable: Iterable<[K, T]>, reconcileFn: Reconciler<K, T, V>): Map<K, V>;
export declare function reverseMap<K, T>(iterable: Iterable<[K, T]>): IterableIterator<[T, K]>;
export declare function mapValues<K, T, V>(iterable: Iterable<[K, T]>, fn: (value: T, key: K) => V): MapStream<K, V>;
export declare function keysOf<K, T>(iterable: Iterable<[K, T]>): IterableIterator<K>;
export declare function valuesOf<K, T>(iterable: Iterable<[K, T]>): IterableIterator<T>;
export declare function uniformMap<K, T>(keys: Iterable<K>, of: T): IterableIterator<[K, T]>;
export declare function selectMap<K, T>(iterable: Iterable<[K, T]>, filterFn: (value: T, key: K) => boolean): IterableIterator<[K, T]>;
export declare function getOrVal<T, V>(map: Map<T, V>, key: T, substitute: V): V;
export declare function foldingGet<T, V, W>(map: Map<T, V>, key: T, ifPresent: (val: V, key: T) => W): W;
export declare function foldingGet<T, V, W>(map: Map<T, V>, key: T, ifPresent: (val: V, key: T) => W, ifAbsent: (key: T) => W): W;
export declare function getOrElse<T, V>(map: Map<T, V>, key: T, substitute: (key: T) => V): V;
export declare function getOrFail<T, V>(map: Map<T, V>, key: T, error?: string | ((key: T) => string)): V;
export declare function flatMakeEntries<T, K, V>(arr: Iterable<T>, expandFn: (value: T) => Iterable<[K, V]>): Iterable<[K, V]>;
export declare function makeEntries<T, K, V>(arr: Iterable<T>, mapFn: (value: T) => [K, V]): Iterable<[K, V]>;
declare type DeepMap1<K, T> = Map<K, T | Map<K, T>>;
declare type DeepMap2<K, T> = Map<K, T | DeepMap1<K, T>>;
declare type DeepMap3<K, T> = Map<K, T | DeepMap2<K, T>>;
declare type DeepMap4<K, T> = Map<K, T | DeepMap3<K, T>>;
declare type DeepMap5<K, T> = Map<K, T | DeepMap4<K, T>>;
declare type DeepMap6<K, T> = Map<K, T | DeepMap5<K, T>>;
declare type DeepMap7<K, T> = Map<K, T | DeepMap6<K, T>>;
declare type DeepMap8<K, T> = Map<K, T | DeepMap7<K, T>>;
export declare type DeepMap<K, T> = DeepMap8<K, T>;
export declare type DeepMapStream<K, T> = Iterable<[K[], T]>;
export declare function squeezeDeepMap<K, T>(deepMap: DeepMap<K, T>): Iterable<T>;
export declare function deepMapStream<K, V>(deepMap: DeepMap<K, V>): Iterable<[K[], V]>;
export declare function deepCollectInto<T, K>(arr: Iterable<[K[], T]>, seed: DeepMap<K, T>): DeepMap<K, T>;
export declare function deepCollectInto<T, K, V>(arr: Iterable<[K[], T]>, seed: DeepMap<K, V>, reconcileFn: Reconciler<K[], T, V>): DeepMap<K, V>;
export declare function deepCollect<T, K>(arr: Iterable<[K[], T]>): DeepMap<K, T>;
export declare function deepCollect<T, K, V>(arr: Iterable<[K[], T]>, reconcileFn: Reconciler<K[], T, V>): DeepMap<K, V>;
export declare function reconcileAppend<T, V, K>(mapFn?: (val: T) => unknown extends V ? T : V): Reconciler<K, T, (unknown extends V ? T : V)[]>;
export declare function reconcileAdd<K>(): Reconciler<K, number, number>;
export declare function reconcileAdd<T, K>(mapFn: (val: T) => number): Reconciler<K, T, number>;
export declare function reconcileCount<K, T>(): Reconciler<K, T, number>;
export declare function reconcileAppendFlat<T, K>(): Reconciler<K, (Possible<T | Iterable<T>>), T[]>;
export declare function reconcileAppendFlat<T, V, K>(mapFn: (val: T) => Possible<V | Iterable<V>>): Reconciler<K, T, V[]>;
export declare function reconcileFold<K, T, V>(mapper: (val: T) => V, reducer: (colliding: V, val: T) => V): Reconciler<K, T, V>;
export declare function reconcileDefault<K, T>(): Reconciler<K, T, T>;
export declare function reconcileFirst<K, T>(): Reconciler<K, T, T>;
export declare function invertBinMap<K, T>(map: Iterable<[K, T[]]>): Map<T, K[]>;
export declare function mapToDictionary<K, T>(map: Iterable<[K, T]>, stringifier?: (val: K) => string): {
    [key: string]: T;
};
export declare function deepFoldingGet<T, V, W>(map: Map<T, V>, lookup: T[], ifPresent: (val: V, keys: T[]) => W, ifAbsent: (keys: T[], matched: T[]) => W): W;
export declare function deepGet<K, T>(map: DeepMap<K, T>, lookup: K[]): T | Map<K, T | Map<K, T | Map<K, T | Map<K, T | Map<K, T | Map<K, T | Map<K, T | Map<K, T>>>>>>>> | undefined;
export declare function deepGetOrVal<K, T>(map: DeepMap<K, T>, lookup: K[], substitute: T): T;
export declare function deepGetOrElse<K, T>(map: DeepMap<K, T>, lookup: K[], substituteFn: (lookup: K[], matched: K[]) => T): T;
export declare function deepGetOrFail<K, T>(map: DeepMap<K, T>, lookup: K[], error?: string | ((follow: K[], matched: K[]) => string)): T;
export declare function deepHas<K, T>(map: DeepMap<K, T>, lookup: K[], error?: string | ((follow: K[], matched: K[]) => string)): boolean;
export declare function deepMapToDictionary<K, T>(map: Iterable<[K, T]>, stringifier?: (val: K, depth: number) => string): {
    [key: string]: unknown;
};
export declare function deepDictionaryToMap<Y>(dictionary: {
    [key: string]: Object;
}): DeepMapStream<string, Y>;
export {};
